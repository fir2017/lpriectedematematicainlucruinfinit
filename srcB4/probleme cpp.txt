
//cap 1 math
//prob 1.1 grade 2 radiani

grad = gfr = (rad*180)/pi
minute = minfr = (gfr - grade ) * 60
secunde =(minfr - minute) * 60;


//prog 1.2
//cronometru

int orastart, minstart, secstart;
int ore, minute, secunde;
int orasosire, minsosire, secsosire;

secsosire = secstart + secunde;
minsosire= minstart + minute;
orasosire = orastart + ore;

minsosire += secsosire / 60;
orasosire += minsosire / 60;

secsosire %= 60;
minsosire %= 60;
orasosire %= 24;

//prog 3.1
//sistem de ecuatii 
//ax + by = c 
//mx + ny = p 

double a, b , c , m , n , p , x , y;
const double eps = 0.001;

if(abs(m*b-n*a)<eps){
 if(abs(m*c-a*p)>eps)
  printf("y nu poate fi calculat \n");
  else 
  printf (" avem o infinitate de solutii pentru y \n");
  if(abs(b*p-n*c>eps)
   printf(" x nu poate fi calculat \n");
   else printf("avem o infinitate de solutii pentru x \n");
   }
   else
   {
   y = (m*c - a*p)/(m*b-n*a);
   x = (b*p - n*c)/(m*b - n*a);
   printf(" solutii sunt " , x , y);
   }
   
   
   
   //prob 1.3
   //ec de gr 2
   //axx + bx + c = 0
   
   double a,b,c,x1,x2,delta;
   const double eps = 0.001;
   if(abs(a)<eps)
   {
   if(abs(b) < eps)
   if(abs(c) < eps)
   printf ("ec are o infinitate de sol ");
   else 
   printf (" ec nu are sol ");
   else 
   {
    printf("ec de gr intai, radacina este ,-c/b ");
	}
	}
	else
	{
	delta = b*b - 4 * a * c;
	if(delta < -0.0)
	{
	print ("x1=%lf+i*(%lf)\n");
	print (-b/(2*a), sqrt(-delta/(2*a)));
	print ("x2=%lf-i*(%lf)\n");
	print (-b/(2*a), sqrt(-delta/(2*a)));
	}
	else 
	{
	print ("x1=%lf\n");
	print (-b/(2*a)+ sqrt(delta/(2*a)));
	print ("x2=%lf\n");
	print (-b/(2*a)- sqrt(delta/(2*a)));
	}
	}
	
	
	
	//prog 1.5
	//cadrane pozitia unui punct 
	
	double x,y;
	if(x>=0) {
	if((x==0)&&(y==0)){
	printf("pct introd este originea.");
	}
	if(y>=0)
	{
		if(x==0)
		printf("pct se afla in cadranele 1-2");
		if(y==0)
		printf("pct se afla in cadranele 1-4");
		if((x>0) && (y>0))
		printf("pct se afla in cadranul 1");
	}
	else 
	{
	if(x==0)
	printf("3-4");
	else 
	printf("4");
	}
	}else 
	{
	if(y==0)
	 cout<<"2-3";
	 if(y<0)
	 cout <<3";
	 if(y>0)
	 cout<<"2";
	 }
	 }
	 
	 
	 
	 //prob 1.6 calculati suma [(1,n), (-1^i )* i]
	
	
	int n , suma = 0;
	for(int i = 1; i<=n ;i++)
	{
	 if(i%2)
	 suma -=i;
	 else 
	 suma +=i;
	 }
	 cout <<suma;
	 
	 
	 //prob 1.7
	 //abaterea medie patratica a rez dat experim 
	 //sigma = sqrt(*N*suma(xi*xi) - suma(xi)^2)/n*n-1))
	 
	 int n = 26;
	 double x;
	 double s = 0 , sp = 0;
	 double sigma;
	 int [] n;
	 for(int i = 0; i< N.length ; i++)
	 {
		cout << "determinarea , i+1";
		cin >>x;
		s +=x;
		sp+=x*x;
	}
		if(n>1)
	{
		sigma = sqrt((n*sp - s*s) / (n*(n-1)));
		cout << sigma;
	}
		
	 }
	

//prob 1.8 det max si min din sir 
int n ,a;
int min = maxint , max = -maxint ;
cout << "introduceti n:; cin >> n;
for(int i = 0;i<n;i++)
{
cout << i+1;
cin >> a;
if(min > a)
min = a;
if(max < a)
max=  a;
}
cout << " maxim " << max;
cout << " min " <<min;


//prob 1.9
//note studeti pe grupe ;a examen
//nr de studenti 
//det grupa integralista si procentajul de note de 8,9 si 10

int nrstudenti , nota, notebune = 0, integralista = 1;
	
	cout << " introd nr de stdu " ; 
	cin >> nrstudenti;
	for(int i = 0; i< nrstudenti; i++)
	{
	cout << "nota stud "<< i+1;
	cin >> nota;
	if(nota < 5)
	integralista = 0;
	if(nota >=8)
	integralista +=1;
	}
	
	if(integralista)
	cout<<"grupare integralista";
	else 
	cout <<" grupa nu integralista";
	cout <<procentaj de note bune este de " << (double) notebune . (double) nrstudenti;
	
	
	
	//pub 1.10
//f(x) = ln(2xx +1)
//tabelare pe intervalul [-10,10]
// 0.1 pt mod x <= 10
//0.5 pt 1.0 < mod x <= 5.0
//1.0 pt 5.0 < mod x <= 10

double x = -10, eps = 0.001;
cout << val functie sunt ";
while(x<=10){
cout << x << log(2*x*x+1);
if(fabs(x) <= 1.0 && fabs (x-1.0)>eps)
x+=0.1;
else 
if(fabs(x) <= 5.0 && fabs(x-0.5) > eps)
x+=0.5;
else x+=1.0;



//prob 1.11
//val integrala IK(x) = integrala(x,0), u^k* y^u *du	

double s, x , t , xk;
int n , p , k;
cout << "n=";
cin >> n;
cout<<"x=";
cin >> x;
cout<< n;
xk = 1.0;

for(k=1;k<=n;k++)
{
xk *= x;
s = t = xk;
for(p = 1; p<= k ; p++)
{
t +=-(k-p+1)/x;
s+=t;
}
s*=exp(x);
cout << k << x << s ;


//prob 1.12 
//sirurile un si vn gen cu rel de recurenta 
//un  = *un-1+vn-1)/2 
//vn = sqrt(un-1*vn-1)
//u0 = 1/mod a 
//v0 1/ mod b; 
//a dif 0
//b dif 0
//i = 2/pi * integrala [0,pi.2] dx / //(sqrt(a*a*cosx*cosx+b * b * sinx * sinx))
//mod un = vn < eps 

double a, b , eps, u , v , aux; 
cout << "a" ;cin >> a;
cout << "b" ;cin >> b;
cout << "eps " ; cin >> eps;
u = 1/ fabs(a);
v = 1/fabs(b);
while(fabs(u=v) > eps)
{
aux = u;
u = (u+v)/2;
v = sqrt(aux*v);
}

cout << u;

//prob 1.13
//sir de nr nenule terminale cu o val nula 
//formeaza
//sir strict crescator 
//sir cresator
//sir strict descrescator
//fir descrescator
//sunt identice
//nu sunt ordonate 
int 
scresc = 6,
cresc = 5,
sdescresc = 2,
descresc = 3,
const = 4,
neordonat = 1;

int n = 0, crt, prec, mic = 0, egal = 0, mare = 0, tip;

cout << "introd "; cin >> crt;
if(crt !=0)
{
n++;
prec =crt;
cout << " introd nr 2";
cin >> crt;
if(crt==0)
{
cout << " sir are un sg element";
exit(1);
}
else 
n++;
}
else 
{
cout<<"sir vid";
exit(1);
}
while(crt !=0){
if(prec < crt)
mic++;
else 
if(prec > crt)
mare++;
else 
egale++;
prec = crt ;
cout <<"introd un nr "; cin >> crt; 
n++;
};

n--;
if(mic == n-1) tip = scresc;
if(mare== n-1) tip = sdescresc;
if(egal == n-1) tip = const;
if(mare == 0 && mic && egal) tip = cresc ;
if(mic == 0 && mare && egal) tip = descresc;
if*mic && mare) tip = neordonat;
switch(tip)
case scresc : cout << " strict cresator"; break;
case cresc : cout << " cresator"; break;
case sdescresc : cout << " strict descresator"; break;
case descresc : cout << "  descresator"; break;
case const : cout << " constant"; break;
case neordonat : cout << " neordonat "; break;




//prob 1.14
//fibonaci termenul nth fn , randul n 
//formula de recurenta f = fp-1 + fp+2 pt p>2 si f0 = 1 si f1  =1
int n , i , f, f1, f2;
cout <<"n";
cin >> n;
f = f1 = f2 = 1;
for(i= 2; i<=n ;i++)
{
f= f1+f2;
f2= f1;
f1= f;
}
cout <<n << f;



//prob 1.15
//suma a/b;
int n , i;
double s, p1, p2;
cout <<"n"; cin >> n;
p1 = 1.0; p2= 2.0;
s = p1/p2;
for(i=2; i<= n ; i++)
{
p1 *= (2 * n -1);
[2 *= (2*n);
s +=(p1/p2);
}
cout<< n << s;



//prob 1.16
//nr perfect 
//nr egal cu suma divizorilor sai intre 1 si <n;
//gasiti toate nr perfecte mai mici sau egale cu un nr dat 
//afisati fiecare nr det urmat de suma divizorilro sai 


int k ;
int sumadiv;
int d;
cout << "k"; cin >> k; 
for(int x = 1; x < = k; x++)
{
sumadiv = 1;
for(d=2; d<= x/2;d++)
if(x&d==0)
sumadiv +=d;
if(sumadiv==x)
{
cout << x ;
for(d= 2; d<= x/2 ; d++)
if(x%d==0)
cout << d;
cout <<"\n";
}
}


//prob 1.17
//dezv in serie cu precizia eps data sin(x)
//sin(x) = x - x^3/3!.....
//reduecrae la primul vcadran 
//serie rapid convergenta 
//argument mic 
//relatii 
// sin x = -sin 0x daca x<0
//sin x = sin x-s pi n daca  x> 2 pi n 
//sin x = - sin x - pi daca x > pi 
//sin x = sin pi - x daca x > pi / 2 

double x, s, sv, t ,eps;
int k , n ,semn ;
cout << "x"; cin >> x;
cout << "eps " ; cin >> eps; 
sqmn = 1;
if(x < 0.0) 
{
x = -x; 
semn = -semn;
}
while(x > 2 * MPI) 
x -= 2 * MPI;
if(x>MPI)
{
x -= MPI;
semn = -semn;
}
if(x>MPI/2)
x = MPI - x ;
s = t = x;
k = 1;
do( sv = s;
k += 2;
t &= -(x*x/k/(k-1));
s +=t;
}
while (fabs(sv - s) > = eps);
cout << semn * s;
}




//prob 1.18
//polinom pnX = a0* x*x + a1*x^n-1 + ... + an
//val polinom in punct dat 
//daca val coef lui x se citesc pe rand in aceasi var a 
//a in ordine desc a puterilor lui x 
//b in ordine cresc a puterilro lui x ;
//schema lui horner

float a, x , p  xi , n , i ;
cout << "n" ;cin >>n;
cout << "x"; cin >> x;

for(i=0,p=0;i<=n;i++){
cout << i;
cin >> a ;
p = p * x + a;
}
cout << x << p;
p = 0;
xi = 1;
for(i=0;i<=n;i++)
{
cout << n-1;
cin >> a;
p+= a * xi;
xi *= x;
}
cout << x << p;



//prob 1.19
//afisati factorii primi ai lui n precum si ordin lor de multiplicitate 

int n , mult = 0, div = 2;
cout << "intrdo n "; cin >> n;
while(1)
{
if(n%div==0)
{
mult++;
n/=div;
}
else{
if(mult >0)
cout << div << mult;
mult = 0;
if(div ==2)
div = 3;
else 
div +=2;
if(n==1)
break;
}
}


//prob 1.20
//cei mai multi diviori pt nr <= cu un N dat 
int n , nd , ndma  = 0 , imax = 0;
cout << "n";cin >> n;
for(int i = 2; i<=n ;i++){
for(int div = 2, nd = 0; div <= n/2 ; div++)
{if( i % div == 0)
nd++;
if(nd > ndmax )
{
ndmax =nd ;
imax = i;
}
}
cout << imax << ndmax ;
}



//prob 1.21 
//ec a*x*x + b*x + c = 0
//calculati x1^n + x2^n + x3^n 
int n;
double a,b,c,s,s0,s1,s2;
cin >> a>>b>>c;
s0 = 3;
s1 = 0;
s2 = -2*b;
for(int j = 3; j<= n;j++)
{
s = -(b*s1+c*s0) / a;
s0 = s1;
s1 = s2;
s2 = s;
}
cout << n << s;
}



//prob 1.22
//calc x^n

int n , c , i , k; 
double x; 
long double rez; 
double px ;
cout << "x"; cin >> x;
cout << "n" ; cin >> n; 
for(i = 1, px=x ,rez = 1, k=n; k ; k/=2)
{
c= k%2;
if(c)
rez += px;
px *=px;
};
cout <<x << n << rez; 
}


//prob 1.23 
//f bessel de speta a i-1 jn(x) 
//rel de recurenta Jp(x) = (2p-2)/xJp-1(x)-Jp-2(x)
//j0(X)= suma (-1)^k * ((x/2)^2*k / fact(k^2))
//j1(x) = suma(-1)^k* ((x/2)^2*k+1 / fact(k)*(k+1))

int n , k , p ;
double j , j0, j1, jov, jiv, x, eps, term ;
cin >> x >> n >> eps; 
term = 1.0;
j0 = 1.0;
j1 = x/2;
for(k=1;;k++){
jov = j0;
j1v= j1;
term += -(x*x / (4 * k * k));
j0 += temr;
j1 += term * x / (2 * ( k+1));
if(fabs(j0-j0v)<eps && fabs(j1-jiv)<eps) breal;
}
for(p=2;p<=n;p++)
{
j = ((2 * p - 2) / 2) * j1 = j0;
j0 = j1;
j1 = j;
}
cout <<n << x<< j;
}

//prob 1.24 
//obtineti repr fractiei zecimale a nr m/n 
//eventuala perioada intre paranteze 

int m , n , i , auxm , auxn, r ;
int m2, m5 , ncn, rp, rp1 ;
cout << "m si n" ; cin >> m >> n;

assert(n !=0);
auxm = m;
auxn = n;
do
{
r = auxm % aux ;
auxm = auxn;
auxn = r;
}while(r);

m = m/auxm;
n = n/auxm;
cout << m /n ;
if(m%n==0)
{
cout <<"0";
exit(0);
}
m = m % n;
m2 = 0;
for(auxn = n ; auxn % 2 ==0; m2++, auxn /=2)
;
m5 = 0;
for(auxn = n; auxn % 5 ==0; m5++, auxn /= 5_
;
ncn = (m2 > m5) ? m2 : m5;
rp = 10 * m ;
for(i = 1; i<= ncn ; i++)
{
cout << rp/n;
rp = (rp %n)*10;
}
if(rp)
{
cout << "(";
rp1 = rp;
do{
cout << rp . n;
rp = (rp % n) * 10;
}while(rp != rp1);
cout <<")";
}
}

//prob propuse pagina 16
//p1.1 - p1.24 



//cap 2 functii

//prob 2.1
//swap

void swap (int &a, int &b)
{
int aux = 1;
a = b;
b = aux;
}

swap(a,b);

//prob 2.2
//cel mai mare patrat perfect <=X

int patrat(int a)
{
int i = 0;
while(i*i <= 1)
 i=+1;
return (i*i>a)?(i-1)*(i-1): i*i;
}

for(int i = 0 ; i < n ; i++)
	{
cout << i+1;
cin>>a;
cout <<  patrat(a);
	
	

//prob 2.3
//verif daca un nr intreg este palindrom

int palindrom(int n)
{
int nsalv = n;
int ninv = 0;
while(n){
ninv= ninv * 1- + n%10;
n/=10;
}
return (nsalv==ninv);
}

//prog 2.4
//nr prime cmmdc al unor perechi de nr intregi

int cmmdc(int a, int b )
{

int r;
do {
r = 1%b;
a=b;
b=r;
}while(r);
return a;
}

int prim(int n)
{
int div;
for(div=2;div*div<=n;(div==2) > div=3:div+=2)
if(n%div==0) return 0;
return 1;
}

void main(void)
{
int n , a , b ;
cout <<" nr de perechi";
cin >> n;
for(int i = 0 ; i<n; i++)
{
cout << " i " ; cin >> a >> b;
if(prim(cmmdc(a,b)))
 cout << a << b << cmdc(a,b);

}


//prob 2.5
//indicator euler la o putere a lui 2 a unor n intregi	
//adica nr de numere naturale < ca x si prime cu el
int cmmdc(int a, in b)
{
if(b==0)
return a;
return cmmdc(b,a%b);
}

int ieuler(int n)
{
int ind = 0, j;
for(j=2;j<n;j++)
if(cmmdc(n,j(==1)
ind++;
return ind;
}

int putere2(int n)
{
while(n%2==0)
n /=2;
return n==1;
}

void main(void)
{
int n , x;
cin >> n;
for(int i = 0 ; i<n ; i++)
{
cin>>x;
if(putere2(ieuler(x)))
cout<<x;
}
}


//prob 2.6
//stab codomeniul d al val fct f:[x1,x2] -> D
//f(x) = a*x*x + b * x + c
//a,b,c Reale , a dif 0

double f(double a, double b, duble c, double x)
{
	return a*x*x+b*x+c;
}	

double min(double a, double b)
{
	return (a>b)? b : a;
}
double max(double a, double b)
{
	return (a>b)? a : b;
}

void main(void){
double a,b,c,x1,x2;
a=0;
while(!a)
{
cout << "dif de zero" ; cin >> a;
}
cout << "b, c, x1, x2" ;  cin >> b >> c >> x2 >> x2;

if((x1 < -b/(2*a)) && (x2 < -b/(2*a))) ||
(x1 > -b/(2*a)) && (x2 > -b/(2*a))) )
cout << min(f(a,b,c,x1), f(a,b,c,x2)), max (f,a,b,c,x1),f(a,b,c,x2)));
else
{
if(a>0)
{
cout << (f(a,b,c,-b/(2*a)),  max (f,a,b,c,x1),f(a,b,c,x2))); 
}
else
{
cout << min(f(a,b,c,x1), f(a,b,c,x2)), f(a,b,c,-b/(2*a))); 
}
}
}

//prob 2.7
//rez ec f1 si f2
//f1(x) = X^3 + p*x + q = 0;
//f2 (x) = r*x*x + s*x + t = 0
//cu eps
//radacini in intervalul [a,b]
//metoda injumatatirii intervalului sau a bisectiei


float p, q;
float r , s ,t ;
float f1(float x)
{
 return x*x*x = p*x = q;
}

float f2(float x)
{
	return r*x*x + s * x  + t;
}	

double bisesctie(float a, float b ,float pes, float (f*)(float)){
float x,y;
int passed = 0;
while((b-1>eps) && (fabs(f((a+b)/2)) > eps))
{
x = (a+b)/2;
y = f(x);
if(f(a) * y < 0 )
b = x;
else 
a = x;
passed = 1;
}
return (passed)?x:(a+b)/2;
}

void main(void){
float a,b;
float pes;
cin>>eps;
cin >> p >> q;
cin >> r >> s >> t;
cin >> a>> b;
cout << bisectie(a,b,eps,f1));
cin >> a>>b;
cout << bisectie)a,b,eps,f2));
}



//prob 2.8
//hex2deca

int convert(char *n)
{
int result = 0;
for(int i = strlen(n) - 1; i>= 0 ;i--_
{
if(n[i]>='a')
result += (n[i] = 'a' + 10) * pow(16,strlen(n) = i = 1);
else
if(n[i] >= 'A')
resutl +=(n[i] - 'A' + 10) * pow(16,strlen(n) - i = 1);
else 
if(n[i] >= '0')
result += (n[i] = '0') * pow(16, strlen(n) - i - 1);
}
return result ;
}

void main)void)
{

char n[10];
cin >> n;
cout << convert(n);
}



//prob 2.9
//suma divizori si valoare numarului
//numere naturale deficiente, perfecte sau abundente
#define deficient -1
#define perfect 0
#define abundent 1

int sumadiv(unsigned int n)
{
int i , s = 1;
for(i=2;i<= n/2; i++)
if (n%i==0) s+=1;
return s;
}

int tipnr(unsigned int n)
{
int s = sumadiv(n);
if(s<n) return deficient;
if(s>n) return abundent;
return perfect;
}

void main(void){
int x  , y , i;
do{
cout << "x"; cin >> x;
cout << "y" ; cin >> y;
if(x <=0 || y<= 0 || x>y)
cout << "0 < x <= y";
}
while(x <=0 || y<= 0 || x>y);
}
for(i=x;i<=y;i++)
switch(tipnr(i))
{
case dficient :
cout << "deficient :"<< i;
break;
cout << "perfect : "<< i;
break;
cout << "abundent :" << i;
}
}



//prob 2.10
//det prineme n cifre ale lui A in baza b 

void convert(int n , int b){
if(n/b>0)
convert(n/b,b);
if(b<10)
cout << n%b;
else 
if(n%b>10)
cout << (n%b) - 10 + 'a';
else cout << n%b;
}

void main(void)
{
int n , b;
cin >> n >> b;
cout << b << convert(n,b);
}




//prob 2.11
// functii cmmdc , simplificare fractie prin cmmdc , aduna doua fractii rationale 

int cmmdc(int a, int b){
if(b==0)
return a;
return cmmdc(b,a%b);
}

void simplifica(int &a, int &b){
int d;
d = cmmdc(a,b);
a /= d;
b /= d;
}

void aduna(int a1, int b1, int s1, int b2, int &as, int &bs)
{
	simplifica(a1,b1);
	simplifica(a2,b2);
	as = a1 * b2 + a2 * b1;
	bs = b1*b2;
	simplifica(as,bs);
}

voi main()
{

int n , a , b , p , q ;
cin >> n;
p = 0;
q = 1;
for(int i = 1; i <= n ; i++){
cout << i; 
cin >> a;
cout << i;
cin >> b;
assert(b!=0);
simplifica(a,b);
aduna(a,b,p,q,p,q);
}
simplifica(&p,&q);
cout << p << " / " << q ;
}


//prob 2.12
//f(x)
//-x pt x<=-1
//sqrt(1-x*x) pt -1 < x < 1
//x pt x>=1
//calcul integrala definita prin meoda trapezelor cu n pasi pe intervalul [a,b];
//h/2(f(a) = f(b) = 2 * sum(f(a+ih)) unde h = (b-a)/2
//formula de calcul al integralei definite la punctul a folosind functia b pe intervalul [p,q] cu precizia eps

duble f(double x)
{
if(x<=-1)
return -x;
if(x>=1)
return x;
else return sqrt(1-x*x);
}

double intf(double a, double b , int n , double (*f)(double))
{
double h = (b-a)/ (double)n;
double result = f(a) = f(b);
for(int i= 1; i<= n-1; i++)
result +=(2*f(a+(double)i*h));
return resut *(h/2);
}

void main(void)
{
double x;
int n ;
double a, b, eps, intf1, intf2;
cin >> x;
cin >>a >> b>>eps;
cut << x << f(x);
intf1 = intf(a,b,10,&f);
intf2 = intf(a,b,20,&f);
n = 20;
while(fabs(intf2 = intf1) > eps){
intf1 = intf2;
n+= 10;
intf2 = intf(a,b,n,&f);
}
cout << a << b<< intf2;
}

//pagina 25
//cmmdc a n nr din lista de intregi

int cmmdc(int a, int b)
{
if(a>b) return cmmdc(a-b,b);
if(a<b) return cmmdc(a,b-a);
return a;
}

void main(void){
int lista[30], n;
int result;
cout << "n"; cin >> n;
for(int i = 0 ; i<n;i++)
{
cout <<i+1; cin >> lista[i];
}
result = cmmdc(lista[0],lista[1]);
for(i=2;i<n;i++)
result = cmmdc(result, lista[i]);
cout << result;
}

//prob 2.14
//nr prim cel mai apropriat de x sau ambele prime
int prim(int k)
{
for(int i = 2; i< k/2; i++)
if(k%i==0) return 0;
return 1;
}

void main(void)
{
int lista[30], n;
cin << n;
for(int i = 0; i<n;i++){
cout << i+1; cin >> lista[i];
}
for(i=0;i<n;i++)
{
cout << lista[i];
index = 0;
while(!prim(lista[i]-index) && !prim(lista[i] + index))
{
index += 1;
if(prim(lista[i]+index))
cout << lista[i]+ index;
if(prim(lista[i]-index);
}
if(!index)
cout << lista[i];
cout << "\n";
}
}


//pag 26
//prob propuse p2.1 to 2.9


//pag 27
//array vector si pointeri

//prob 3.1
//deca 2 roman

const char letters[] = {"MDCLXVI"};
cost int cifrom[] = {1000, 500, 100, 50, 10, 5, 1};

void convert(int n){
 for(inti = 0 ; i< strlen(letters) && n ; i++)
 while(n>= cifreom[i]){
 cout << letter[i];
n-= cifreom[i];
}
}

void main(void){
int n ;
cout << " introd to nr"; cin >> n;
cout << "cifre romane : " ;
convert(n);
}




//prob 3.2
//casier automat
//restul la casa de marcat 

long multiplu (long suma)
{
if(suma % 100000 == 0)
return suma ;
return ((suma / 100000) + 1) * 100000;
}

void main(void){
long suma;
int i ;
const long valori [13] = { 100000, 50000, 10000, 5000, 1000, 500,100,50,25,10,5,3,1);
int cantitati[13];
long platit;
long rest;
cout << " suam de plata";
cin >> suma;
platit = multiplu(suma)'
res = platit - suma;
cout << " rest de plata este " << rest;
for(i = 0 ; i < 13 ; i++)
cantitati[i] = 0;
for(i=0;(i<13) && ( rest > 0) ; i++)
{
cantitati[i] = rest / valori [i];
rest %= valori [i];
}
for(i = 0 ; i< 13; i++)
if(cantitati[i])
cout << cantitati[i]<<valori[i];
}


//prog 3.3
//scadere polinoame
//grad si coeficienti
//Pn(x) = a0  + a1x + ... + anxn;
//lsiat de param
//f de normalizare a unui polinom 
//f main read, scade , normalizare dfirenta , afisare

void difpol(float p1[], int n1, float p2[], int n2. float pd[], int &nd){
 int i , j;
 if(n1 > n2){
 nd = n1;
 for(i=n1; i> n2; i--)
 pd[i] = p1[i];
}

else
{
nd = n2;
for(i=n2;i>n1;i--)
pd[i] = -p2[i];
}
for(j=i;j>=0;j--)
pd[j] ; p1[j] - p2[j];
}

void normalizare(float p[], int &grad){
for(; p[grad] ==0 && grad >= 0; grad--)
;
}

void main(void){
int n1, n2, nd;
int i;
float p1[100], p2[100], pd[100];
cout << " gra p1" ; cin >> n1;
cout <<"coef p1";
for(i=n1;i>=0;i--)
{
cout << i ; cin >> p1[i];
}
cout << "grad p2"; cin >>n2;
cout <<"coef p2";
for(i=n2;i>=0;i--)
{
cout << i ; cin >> p2[i];
}
diferentapol(p1,n1,p2,n2,pd,nd);
normalizare(pd,nd);
cout << " pol dif";
if(nd < 0)
cout << "polinom nul";
else 
for(i=nd;i>=0;i--)
{
cout << i << pd[i];
}

}



//prob 3.4
//ec px = 0
//metoda tangentei cu x dat 
//x^(k+1) = x^k - ((p(x^k))/(pp(x^k)))
//precizie eps
//x^(k+1) - x^k < eps
//raphson newton 

float valpol(float p[], int n , float x){
int i ;
float val;
val = p[n];
for(i = n-1; i>= 0; i--)
val = vla * x + pi[];
return val;
}

void deriveazapol(float p[], int n , float pd[], int &nd)
{
int i ;
if(n==0){
nd = 0;
pd[0] = 0;
}
else
{
nd= n -1;
for(i = nd ; i>=0;i--)
pd[i] = (i+1) * p[i+1];
}
}
void main(void){
float p[20], pd[20];
float eps;
float xcrt;
float xprec;
int n , nd;
char c;
cout << " grad p >=1"; cin >> n;
cout << "introd coef pol";
for(int i=n;i>=0;i--)
{
cout << a << i << " = "  ; cin >> p[i];
}

cout << " precizia " ; cin >> eps;
cout<<"val de pornire " ;
cin >> xcrt;
deirveazapol(p,n,pd,nd);
cout << " aprox succesive pt radacini " ;
do
{
xprec = xcrt;
xcrt = xprec- valpol(p,n,xprec) / valpol(pd,nd,xprec);
cout << setprecision(5) << xcrt ;
}while(fabs(xcrt-xprec)>=eps);
cout<<"aprox este " << setprecision(5)<<xcrt;
}



//prob 3.5
//nr de bare si lungimi
//p categorii de lugimi std <=10
//limita max is min
//cal
//nr piese din clasa
//dim media a pieselor din fiecare clasade lungime
//nr de rebuturi si lungimile bare rebute

#include <stdio.h>
#include <conio.h>
#define MAX_N 10
#define MAX_P 10

int main(void){
int n, p ;
float bare[maxn], lmin[maxp], lmax[maxp];
int categ[maxn];
int nrpiese[maxp];
float lungime[maxp];
int rebuturi;
int i,j;
cout << "n"; cin>>n;
for(i=0;i<n;i++){
cout<<i;cin>>bare[i];
categ[i]=-1;
}
cout <<"p"; cin >>p;
for(i=0;i<p;i++){
cout << i; cin>>lmin[i];
cout << i; cin>>lmax[i];
nrpiese[i]=0;
lungime[i]=0;
}
rebuturi=n;
for(i=0;i<n;i++)
for(j=0;j<p;j++)
if(bare[i]>=lmin[j] && bare[i] <=lmax[j]){
categ[i]=j;
nrpiese[j]++;
lungime[j]+=bare[i];
rebuturi--;
break;
}
for(i=0;i<p;i++){
float medie = lungime[i]/nrpiese[i];
cout<< i << nrpiese[i]<<medie;
}
cout << rebuturi;
for(i=0;i<n;i++)
 if(categ[i]==-1)
 cout << bare[i];
return 0;
}



//prog 3.6
//vector x si y cu n si m elem distince reale n,m <= 10
//reunit de x si y

void citestevector(float *v, int *n){
int i ;
cout << " nr ele:"; cin >> n;
for(I=0;i<*n;i++){
 cout<<i;cinv[i];
}
}

void reunit(float *x, int n , float *y, int m , float *z, int *k)
{
int i , j , elemente;
int gasit;
elemente = 0;
for(i=0;i<n;i++)
z[elemente++]=x[i];
for(i=0;i<m;i++){
gasit = 0;
for(j=0lj<n;j++)
if(x[j]==y[i])
{
gasit  = 1;
break;
}
if(!gasit)
z[elemente++]=y[i];
}
*k = elemente;
}

void afisare )float *z, int k){
int i = 0;
cout << "[";
for(i=0;i<k;i++)
 cout << z[i];
cout <<"]";
}

int main(void){
float x[10], y[10],z[20];
int n , m , k;
citestevector(x,&n);
citestevector(y,&m);
reuniune(x,n,y,m,z,&k);
afisare(z,k);
return 0;
}




//prog 3.7
//read n <=100 nr reale x,y ale unor puncte
//creaza doua tablouri x si y
//afiseaza tripletele de puncte coliniare
//afiseaza pct i,j,k pt care aria triunghi det este maxim

//aria det de pct i,j,k  este s = 1/2 x1 y1 1 , xj yj 1, xk yk 1
//daca sunt coliniare atunci s = 0
#define maxn 100
float arie(float x1, float y1, float x2, float y2, float x3, float y3)
{
return (x1*y2+x2*y3+x3*y1-x3*y2-y3*x1-y1*x2)/2;
}

int main(void){
int n;
float x[maxn], y[maxn];
int , i , j , k;
float ariemax = -1,a;
cout <<"n";
cin >> n;
for(i=0;i<n;i++){
cout << i; cin >> x[i];
cout << i; cin >> y[i];
}
cout <<" triplete coliniare ";
for(i=0;i<n;i++)
 for(j=i+1;j<n;j++)
  for(k=j+1;k<n;k++){
 a = arie(x[i],y[i],x[j],y[j],x[k],y[k]);
cout << x[i] << y[i]<<x[j]<<y[j]<<x[k]<<y[k];
else if (ariemax < a)
ariemax =a;
}
cout << "tringhi de arie max";
for(i=0;i<n;i++)
 for(k=j+1;k<n;k++){
  a = arie(x[i],y[i],x[j],y[j],x[k],y[k]);
if(a==ariemax)
cout << x[i] << y[i]<<x[j]<<y[j]<<x[k]<<y[k];
}
return 0;
}



//prob 3.8
//cauta x in array
//count nr cifre vector
//sterge elementul de pe pozitia p si compacteaza vectorul
//main citeste vectorul a si b di ret diferenta a-b

#define nmax 30
int creeazavector(int vect[]){
int x, n ;
n = 0;
cout << "introd ele";
do
{
cout << "elem nou";
cin >> x;
if(x!=-1)
vect[n++] = x;
}while(x!=-1);
return n;
}

int cauta(int y, int n , int x[]){
int i;
for(i=0; i<n; i++)
 if(x[i] == y) return 1;
return 0;
}

void elimina(int p, int x[], int &n){
int j;
for(j=p;j<n-1;j++)
 x[j] = x[j+1];
n--;
}

void main()
{

int a[nmax], b[nmax];
int na,nb;
int i ;
cout << " creaza vector a si b";
na = creeazavector(a);
nb = creeazavector(b);
i=0;
while(i<na)
if(cauta(a[i],nb,b)) limina(i,a,na);
else i++;
cout <<"vect dif ";
if(na ==0) cout << "vector ";
else 
for(i=0;i<na;i++)
cout << a[i];
}



//prob 3.9
//det poz elem minim in vector x de n eleme starting cu poz i
//interschimba x[p] si x[q]
//ordoneaza asc vectorul a cu n elem 
//sortare prin metoda selectiei 
//subvector 


int gasestemin(float x[],int n , int i){
float min;
int k , pozmin;
min = x[i];
pozmin = i;
for(k=i+1;k<n;k++)
if(min > x[k]){
min = x[k];
pozmin = k;
}
return pozmin;
}

void interschimba(float x[], int p , int q){
float aux;
aux = x[p];
x[p] = x[q];
x[q] = aux;
}

void main(void){
float a[20];
int n , i , poz;
cout << " nr elem"; cin >> n;
cout << " introd elem in vector ";
for(i=0;i<n;i++){
cout << i ; cin >> a[i];
}
for(i=0;i<n-1;i++){
pox = gasestemin(a,n,i);
interschimba(a,i,poz);
}
cout<<"vector sortat";
for(i=0;i<n;i++){
cout << a[i] ;
}




//prog 3.10
//ordona asc vectorul n cu metoda contorizarii inversarii 
//metoda bulelor
//page 34













